// Generated by CoffeeScript 1.6.3
(function() {
  var Q, amqp, log;

  log = require('bog');

  Q = require('q');

  amqp = require('amqp');

  module.exports = function(conf) {
    var bind, conn, exchange, isShutdown, queue, shutdown, unbind;
    if (conf.local) {
      log.info("conf.local=true means no amqp connection");
    }
    isShutdown = false;
    conn = (function() {
      var def, mq, _ref;
      if (conf.local) {
        return Q({
          local: true
        });
      }
      log.info("Connecting", conf);
      def = Q.defer();
      mq = amqp.createConnection(conf);
      mq._ttQueues = (_ref = mq._ttQueues) != null ? _ref : {};
      mq.on('ready', function(ev) {
        log.info('amqp connection ready');
        return def.resolve(mq);
      });
      mq.on('error', function(err) {
        if (def.promise.isPending()) {
          def.reject(err);
          mq.backoff = mq.reconnect = function() {
            return false;
          };
          return log.warn('amqp connection failed:', err);
        } else if (def.promise.isFulfilled()) {
          if (!isShutdown) {
            return log.warn('amqp connection failed:', (err.message ? err.message : err));
          }
        }
      });
      return def.promise;
    })();
    exchange = function(name, opts) {
      var def;
      if (conf.local) {
        throw new Error('Unable connect exchange when conf.local = true');
      }
      if (isShutdown) {
        throw new Error('Unable connect exchange when shutdown');
      }
      def = Q.defer();
      conn.then(function(mq) {
        var prom, _ref;
        mq._ttExchanges = (_ref = mq._ttExchanges) != null ? _ref : {};
        prom = mq._ttExchanges[name];
        if (prom) {
          return prom.then(function(ex) {
            return def.resolve(ex);
          });
        }
        mq._ttExchanges[name] = def.promise;
        opts = opts != null ? opts : {
          passive: true
        };
        return mq.exchange(name, opts, function(ex) {
          log.info('exchange ready:', ex.name);
          return def.resolve(ex);
        });
      }).done();
      return def.promise;
    };
    queue = function(qname, opts) {
      var def;
      def = Q.defer();
      conn.then(function(mq) {
        var prom;
        prom = mq._ttQueues[qname];
        if (prom) {
          return prom.then(function(q) {
            return def.resolve(q);
          });
        }
        if (qname) {
          mq._ttQueues[qname] = def.promise;
        }
        return mq.queue(qname, opts, function(queue) {
          log.info('queue created:', queue.name);
          if (!qname) {
            mq._ttQueues[queue.name] = def.promise;
          }
          return def.resolve(queue);
        });
      }).done();
      return def.promise;
    };
    bind = function(exname, qname, topic, callback) {
      var def;
      if (conf.local) {
        throw new Error('Unable to bind when conf.local = true');
      }
      if (isShutdown) {
        throw new Error('Unable to bind when shutdown');
      }
      if (typeof topic === 'function') {
        callback = topic;
        topic = qname;
        qname = "";
      }
      if (!qname) {
        qname = "";
      }
      def = Q.defer();
      (unbind(qname)).then(function() {
        var opts;
        opts = {
          durable: true
        };
        opts.autoDelete = qname === "";
        return Q.all([exchange(exname), queue(qname, opts)]);
      }).spread(function(ex, q) {
        log.info('binding:', exname, q.name, topic);
        q.bind(ex, topic);
        return q.on('queueBindOk', function() {
          var wrap;
          wrap = function() {
            var err;
            try {
              return callback.apply(null, arguments);
            } catch (_error) {
              err = _error;
              return log.error(err);
            }
          };
          return (q.subscribe(wrap)).addCallback(function(ok) {
            var ctag;
            ctag = ok.consumerTag;
            q._ttCtag = ctag;
            q._ttEx = ex;
            q._ttTopic = topic;
            log.info('consumer bound:', q.name, ctag);
            return def.resolve(ex);
          });
        });
      }).done();
      return def.promise;
    };
    unbind = function(qname) {
      var def;
      def = Q.defer();
      conn.then(function(mq) {
        var qp;
        if (mq.local) {
          return def.resolve(true);
        }
        qp = mq._ttQueues[qname];
        if (!qp) {
          return def.resolve(mq);
        }
        return qp.then(function(q) {
          if (!q._ttEx) {
            return def.resolve(conn);
          }
          log.info('unbinding:', qname);
          q.unbind(q._ttEx, q._ttTopic);
          return q.on('queueUnbindOk', function() {
            var ctag;
            ctag = q._ttCtag;
            delete q._ttCtag;
            delete q._ttEx;
            delete q._ttTopic;
            q.unsubscribe(ctag);
            delete mq._ttQueues[qname];
            log.info('consumer unbound:', qname, ctag);
            return def.resolve(mq);
          });
        });
      }).done();
      return def.promise;
    };
    shutdown = function() {
      var def;
      isShutdown = true;
      def = Q.defer();
      conn.then(function(mq) {
        var qname, qp;
        if (mq.local) {
          return def.resolve(true);
        }
        log.info('closing amqp connection');
        return Q.all((function() {
          var _ref, _results;
          _ref = mq._ttQueues;
          _results = [];
          for (qname in _ref) {
            qp = _ref[qname];
            _results.push(unbind(qname));
          }
          return _results;
        })()).then(function() {
          mq.backoff = mq.reconnect = function() {
            return false;
          };
          mq.end();
          log.info('amqp closed');
          return def.resolve(true);
        });
      }).done();
      return def.promise;
    };
    return {
      exchange: exchange,
      bind: bind,
      shutdown: shutdown,
      local: conf.local
    };
  };

}).call(this);
