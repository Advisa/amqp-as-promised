// Generated by CoffeeScript 1.6.3
(function() {
  var Q, QueueWrapper, amqp, log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  log = require('bog');

  Q = require('q');

  amqp = require('amqp');

  module.exports = function(conf) {
    var bind, conn, exchange, isShutdown, queue, shutdown, shutdownDef, unbind;
    if (conf.local) {
      log.info("conf.local=true means no amqp connection");
    }
    isShutdown = null;
    conn = (function() {
      var def, mq, _ref;
      if (conf.local) {
        return Q({
          local: true
        });
      }
      log.info("Connecting", conf);
      def = Q.defer();
      mq = amqp.createConnection(conf);
      mq._ttQueues = (_ref = mq._ttQueues) != null ? _ref : {};
      mq.on('ready', function(ev) {
        log.info('amqp connection ready');
        return def.resolve(mq);
      });
      mq.on('error', function(err) {
        if (def.promise.isPending()) {
          def.reject(err);
          mq.backoff = mq.reconnect = function() {
            return false;
          };
          return log.warn('amqp connection failed:', err);
        } else if (def.promise.isFulfilled()) {
          if (!isShutdown) {
            return log.warn('amqp connection failed:', (err.message ? err.message : err));
          }
        }
      });
      return def.promise;
    })();
    exchange = function(name, opts) {
      var def;
      if (conf.local) {
        throw new Error('Unable connect exchange when conf.local = true');
      }
      if (isShutdown) {
        throw new Error('Unable connect exchange when shutdown');
      }
      def = Q.defer();
      conn.then(function(mq) {
        var prom, _ref;
        mq._ttExchanges = (_ref = mq._ttExchanges) != null ? _ref : {};
        prom = mq._ttExchanges[name];
        if (prom) {
          return prom.then(function(ex) {
            return def.resolve(ex);
          });
        }
        mq._ttExchanges[name] = def.promise;
        opts = opts != null ? opts : {
          passive: true
        };
        return mq.exchange(name, opts, function(ex) {
          log.info('exchange ready:', ex.name);
          return def.resolve(ex);
        });
      }).done();
      return def.promise;
    };
    queue = function(qname, opts) {
      var def;
      if (conf.local) {
        throw new Error('Unable to connect queue when conf.local = true');
      }
      if (isShutdown) {
        throw new Error('Unable to connect queue shutdown');
      }
      if (qname !== null && typeof qname === 'object') {
        opts = qname;
        qname = '';
      }
      if (!qname) {
        qname = '';
      }
      opts = opts != null ? opts : {
        durable: true,
        autoDelete: qname === ''
      };
      def = Q.defer();
      conn.then(function(mq) {
        var prom;
        if (qname !== '') {
          prom = mq._ttQueues[qname];
          if (prom) {
            return prom.then(function(q) {
              return def.resolve(q);
            });
          }
          mq._ttQueues[qname] = def.promise;
        }
        return mq.queue(qname, opts, function(queue) {
          log.info('queue created:', queue.name);
          if (qname === '') {
            mq._ttQueues[queue.name] = def.promise;
          }
          return def.resolve(new QueueWrapper(conn, queue));
        });
      }).done();
      return def.promise;
    };
    bind = function(exname, qname, topic, callback) {
      var def;
      if (conf.local) {
        throw new Error('Unable to bind when conf.local = true');
      }
      if (isShutdown) {
        throw new Error('Unable to bind when shutdown');
      }
      if (typeof topic === 'function') {
        callback = topic;
        topic = qname;
        qname = '';
      }
      if (!qname) {
        qname = '';
      }
      def = Q.defer();
      (Q.all([exchange(exname), queue(qname)])).spread(function(ex, q) {
        return q.bind(ex, topic);
      }).then(function(q) {
        return q.subscribe(callback);
      }).then(function() {
        return def.resolve(qname);
      }).done();
      return def.promise;
    };
    unbind = function(qname) {
      var def;
      def = Q.defer();
      conn.then(function(mq) {
        var qp;
        if (mq.local) {
          return def.resolve(true);
        }
        qp = mq._ttQueues[qname];
        if (!qp) {
          return def.resolve(mq);
        }
        return qp;
      }).then(function(q) {
        return q.unbind();
      }).then(function(q) {
        return q.unsubscribe();
      }).then(function() {
        return def.resolve(qname);
      }).done();
      return def.promise;
    };
    shutdownDef = null;
    shutdown = function() {
      var def;
      if (isShutdown) {
        return isShutdown.promise;
      }
      def = isShutdown = Q.defer();
      conn.then(function(mq) {
        var qname, qp;
        if (mq.local) {
          return def.resolve(true);
        }
        return Q.all((function() {
          var _ref, _results;
          _ref = mq._ttQueues;
          _results = [];
          for (qname in _ref) {
            qp = _ref[qname];
            _results.push(unbind(qname));
          }
          return _results;
        })()).then(function() {
          log.info('closing amqp connection');
          mq.backoff = mq.reconnect = mq.connect = function() {
            return false;
          };
          mq.end();
          log.info('amqp closed');
          return def.resolve(true);
        });
      }).done();
      return def.promise;
    };
    return {
      exchange: exchange,
      queue: queue,
      bind: bind,
      shutdown: shutdown,
      local: conf.local
    };
  };

  QueueWrapper = (function() {
    function QueueWrapper(conn, queue) {
      this.conn = conn;
      this.queue = queue;
      this.shift = __bind(this.shift, this);
      this.unsubscribe = __bind(this.unsubscribe, this);
      this.subscribe = __bind(this.subscribe, this);
      this.unbind = __bind(this.unbind, this);
      this.bind = __bind(this.bind, this);
      this.qname = this.queue.name;
    }

    QueueWrapper.prototype.bind = function(ex, topic) {
      var def,
        _this = this;
      if (!(ex || typeof ex !== 'object')) {
        throw new Error('Exchange is not an object');
      }
      if (!(topic || typeof topic !== 'string')) {
        throw new Error('Topic is not a string');
      }
      def = Q.defer();
      this.unbind().then(function() {
        log.info('binding:', ex.name, _this.qname, topic);
        _this.queue.bind(ex, topic);
        return _this.queue.once('queueBindOk', function() {
          _this._ex = ex;
          _this._topic = topic;
          log.info('queue bound:', _this.qname, _this._topic);
          return def.resolve(_this);
        });
      }).done();
      return def.promise;
    };

    QueueWrapper.prototype.unbind = function() {
      var def,
        _this = this;
      def = Q.defer();
      if (!this._ex) {
        def.resolve(this);
        return def.promise;
      }
      this.conn.then(function(mq) {
        _this.queue.unbind(_this._ex, _this._topic);
        return _this.queue.once('queueUnbindOk', function() {
          log.info('queue unbound:', _this.qname, _this._topic);
          delete _this._ex;
          delete _this._topic;
          return def.resolve(_this);
        });
      }).done();
      return def.promise;
    };

    QueueWrapper.prototype.subscribe = function(opts, callb) {
      var def,
        _this = this;
      def = Q.defer();
      if (typeof opts === 'function') {
        callb = opts;
        opts = null;
      }
      opts = opts != null ? opts : {
        ack: false,
        prefetchCount: 1
      };
      if (!(opts || typeof opts !== 'object')) {
        throw new Error('Opts is not an object');
      }
      if (!(callb || typeof callb !== 'function')) {
        throw new Error('Callback is not a function');
      }
      this.unsubscribe().then(function() {
        var wrapper;
        wrapper = function() {
          var err;
          try {
            return callb.apply(null, arguments);
          } catch (_error) {
            err = _error;
            return log.error(err);
          }
        };
        return (_this.queue.subscribe(opts, wrapper)).addCallback(function(ok) {
          var ctag;
          ctag = ok.consumerTag;
          _this._ctag = ctag;
          log.info('subscribed:', _this.qname, ctag);
          return def.resolve(_this);
        });
      }).done();
      return def.promise;
    };

    QueueWrapper.prototype.unsubscribe = function() {
      var ctag, def;
      def = Q.defer();
      if (!this._ctag) {
        def.resolve(this);
        return def.promise;
      }
      ctag = this._ctag;
      delete this._ctag;
      this.queue.unsubscribe(ctag);
      log.info('unsubscribed:', this.qname, ctag);
      def.resolve(this);
      return def.promise;
    };

    QueueWrapper.prototype.shift = function() {
      return this.queue.shift.apply(this.queue, arguments);
    };

    return QueueWrapper;

  })();

}).call(this);
